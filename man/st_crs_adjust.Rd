% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/st_crs_adjust.R
\name{st_crs_adjust}
\alias{st_crs_adjust}
\title{Revert transformation of \code{sf} object among \code{gcj02}, \code{bd09} and \code{wgs} coordinate systems}
\usage{
st_crs_adjust(
  obj,
  from = "gcj",
  to = "wgs",
  accurate = TRUE,
  check_extent = TRUE
)
}
\arguments{
\item{obj}{A \code{sf} class object to be transformed}

\item{from}{A string of the shortcut coordinate system name of \code{obj}, should be one of "gcj", "bd" and "wgs"}

\item{to}{A string of the shortcut coordinate system name of the output, should be one of "gcj", "bd" and "wgs"}

\item{accurate}{A logical value (TRUE or FALSE) that indicates whether to use a more accurate algorithm. \cr
The more accurate code is written in C++, theoretically it would be efficient. \cr
However, if execution time is excessive, consider switching to \code{FALSE} to use a less accurate but faster mode.}

\item{check_extent}{A logical value (TRUE or FALSE) that indicates whether to check if the input object is approximately within the extent of China. Setting this to FALSE can improve performance for large datasets, as the check will be skipped.}
}
\value{
A \code{sf} class object, with modified geometry after transformation
}
\description{
Revert transformation of \code{sf} object among \code{gcj02}, \code{bd09} and \code{wgs} coordinate systems
}
\examples{
test_point = cbind(data.frame(x = 1), sf::st_sfc(sf::st_point(c(120,36))))
st_crs_adjust( sf::st_as_sf(test_point,crs = 4326))
}
